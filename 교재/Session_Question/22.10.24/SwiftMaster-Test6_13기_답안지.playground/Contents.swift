import UIKit

/*:
# 앨런 - Swift 마스터 스쿨 13기
*/
/*:
## 여섯번째 테스트 (7주차)
---
*/
/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 그동안 배운 내용의 복습 및 약간의 응용이 들어가 있을 뿐입니다. 이 문제를 잘 풀 수 있다고
 좋은 개발자가 될 수 있는 것도 아니고, 실망하거나 좌절할 필요도 없습니다.
 우린 이제 시작일 뿐입니다. 😄
 가장 중요한 것은 포기하지 않고, 꾸준함을 유지하는 것일뿐!
 안풀리면, 다음 문제로 넘어가면되고, 이번에 못풀면 잘 공부해서, 다음 번에 똑같은 문제를 잘 풀면됩니다.
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/

// 서술형의 경우, 주석처리를 하고 작성하면 됩니다.
// (시간이 약간 모자랄 수도 있을 것 같긴한데, 되는 대로 풀어서, 슬랙 DM으로 전달해 주세요!)

// 꼭 정해진 시간 이외에도 풀어보시는대로 전달해 주시면,
// 제가 대략적으로 실력을 파악하는데 도움이 됩니다. (조언도 드릴 수 있고요!)




/**==================================================================
 [1번 문제]
  - 클래스(Class)와 구조체(Struct)의 차이점은? 가장 중요한 차이점 위주로 간단하게
    서술하세요.
 ===================================================================**/

// 실제로 디테일하게는 여러가지 차이점이 있지만, 아래 가장 중요한 차이점 2가지는
// 반드시 외우고 있어야 함

// 1) 상속 가능 여부
//    (1) 클래스는 상속가능
//    (2) 구조체는 상속 불가능

// 2) 메모리 저장의 방식의 차이
//    (1) 클래스의 인스턴스는 Heap (참조 타입)
//    (2) 구조체의 인스턴스는 Stack (값 타입)






/**==================================================================
 [2번 문제]
  - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있습니다. Bclass의 저장속성인
    z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
    (init(x: Int, y: Int))를 "지정생성자"(⭐️)로 재정의 해보세요.
    (편의생성자 아님! 내부는 자유롭게 구현해보세요.)
 ===================================================================**/


class Aclass {
    var x: Int
    var y: Int
    
    init(x: Int, y: Int) {
        self.x = x
        self.y = y
    }
    
    convenience init() {
        self.init(x: 0, y: 0)
    }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

    var z: Int

    // 이 부분에 지정생성자를 2개 (상위의 지정생성자를 재정의한 것 포함) 구현
    init(x: Int, y: Int, z: Int) {
        self.z = z                // (현 단계에서) 새로운 저장속성을 추가했기 때문에, 값을 셋팅할 필요 ⭐️
        super.init(x: x, y: y)   // 나머지 x, y 는 상위에서 구현했기 때문에, 실제 메모리 값을 찍어내는 것은 상위지정생성자에서만 가능 ⭐️
    }
    
    // 상위의 지정생성자(init(x: Int, y: Int))와 동일한 이름을 사용했기 때문에 - 재정의
    override init(x: Int, y: Int) {
        self.z = 0              // (현 단계에서) 새로운 저장속성을 추가했기 때문에, 값을 셋팅할 필요 ⭐️
        super.init(x: x, y: y)  // 나머지 x, y 는 상위에서 구현했기 때문에, 실제 메모리 값을 찍어내는 것은 상위지정생성자에서만 가능 ⭐️
    }
}




/**==================================================================
 [3번 문제]
  - 아래 Hero 클래스가 구현되어 있습니다. 해당 Hero클래스는 이름(name)과 아이디(id)로
    인스턴스를 생성할 수 있는데, 해당 클래스를 확장(Extension)해서,
    이름만으로도 인스턴스를 생성할 수 있는.. (확장에서) 생성자를 구현하세요.
    (아이디는 0으로 셋팅되도록 구현하시면 됩니다.)
    (힌트. 확장에서, 생성자의 구현에서, 주의할점은...?)
 ===================================================================**/



class Hero {
    var name: String
    var id: Int
    
    init(name: String, id: Int) {
        self.name = name
        self.id = id
    }
}

extension Hero {
    // 이 부분을 이름만 가지고 생성할 수 있는 생성자로 구현 하세요.
    convenience init(name: String) {
        self.init(name: name, id: 0)
    }
}


var hero1 = Hero(name: "아이언맨", id: 0)
var hero2 = Hero(name: "캡틴아메리카", id: 1)
var hero3 = Hero(name: "헐크", id: 2)



// 위의 확장에서, 생성자를 제대로 구현하면 아래의 코드가 사용 가능해 집니다.
var hero4 = Hero(name: "토르")
var hero5 = Hero(name: "스파이더맨")



/**==================================================================
 [4번 문제]
  - Any와 AnyObject타입의 차이는 뭔가요? 아는대로 간단하게 서술하세요.
 ===================================================================**/

// 1) Any타입
// 스위프트의 기본 타입(Int, String, Double, Bool), 열거형, 클래스, 구조체, 함수 등
// 어떤 타입의 인스턴스도 표현할 수 있는 타입

// 2) AnyObject타입
// 어떤 "클래스" 타입의 인스턴스도 표현할 수 있는 타입






/**==================================================================
 [5번 문제]
  - 아래의 조건을 만족하는 RemoteControl 프로토콜의 구현을 완성해 보세요.
    (조건)
    (1) name 속성(타입: String)을 요구사항으로 선언
        (최소한의 요구사항은 읽기 속성 강제하기)
    (2) turnOn 메서드를 요구사항으로 선언
        (input: 없음, output: Bool)
    (3) turnOff 메서드를 요구사항으로 선언
        (input: (num: Int), output: Bool)
 ===================================================================**/

// RemoteControl 프로토콜
protocol RemoteControl {
    var name: String { get }
    func turnOn() -> Bool
    func turnOff(num: Int) -> Bool
}







/**==================================================================
 [6번 문제]
  - 프로토콜(Protocol)의 확장(Extension)이 어떤 개념인가요? 아는대로 간단하게 서술하세요.
 ===================================================================**/

// 프로토콜의 확장에서는, 프로토콜의 선언에서 요구하는 필수요구 사항 메서드 등의
// 기본적인(default) 구현(즉, 실제 구현)을 제공함

// 따라서, 기본 구현이 제공되는 메서드의 경우, 해당 프로토콜을 채택한 타입(클래스, 구조체) 등에서
// 해당 메서드를 반복적으로 구현하지 않아도 되는 편의성이 생김
// 다만, 해당 기본구현을 무시하고 직접적으로 구현하는 것도 가능함






/**==================================================================
 [7번 문제]
  - 고차함수를 사용해서, 아래 array배열에서, 5보다 큰 짝수를 뽑아내세요. 해당 뽑아낸
    숫자들을 evenNumbersArray 변수에 담으면 됩니다.
    (힌트. 고차함수 두번 사용 가능)
 ===================================================================**/

let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]


// 아래, array 배열에 고차함수 사용하는 코드 완성하세요.
var evenNumbersArray = array.filter { $0 > 5 }.filter { $0 % 2 == 0 }




// 이 코드는 출력(확인)을 위한 코드 입니다.
print(evenNumbersArray)






/**==================================================================
 [8번 문제]
  - 아래 Student구조체가 정의되어 있고, 해당 구조체의 인스턴스를 담고 있는
    someMembers 배열이 있습니다. someMembers 배열에서, 고차함수 방식을 이용해서
    친구의 이름이 "아이브"를 가진 멤버만 뽑아내서, 출력을 해보세요.
 
  - 힌트. (1) someMembers.고차함수 사용  (2) contains 메서드
 
  - 고차함수로 잘 완성을 했다면, 그 아래 newMembers.map { print($0.name) }
    이 부분을 통해서, "잡스", "팀쿡" 이 두명의 이름을 정상적으로 출력을 할 수 있습니다.
 ===================================================================**/


struct Student {
    let name: String
    let studentId: Int
    let friendsName: [String]
}


let someMembers: [Student] = [
    Student(name: "잡스", studentId: 0, friendsName: ["팀쿡", "아이브"]),
    Student(name: "팀쿡", studentId: 0, friendsName: ["잡스", "아이브"]),
    Student(name: "주커버그", studentId: 0, friendsName: ["빌게이츠", "마이클"]),
    Student(name: "베조스", studentId: 0, friendsName: ["빌게이츠", "존"])
]



// 아래, someClassMembers 배열에 고차함수 사용하는 코드 완성하세요.
var newMembers = someMembers.filter { $0.friendsName.contains("아이브") }



// 이 코드는 출력(확인)을 위한 코드 입니다.
newMembers.map { print($0.name) }

// 잡스
// 팀쿡





/**==================================================================
 [9번 문제]
  - 반복문에서 for문 대신에 map, filter, reduce 를 사용할 수 있습니다. 각각을
    간단하게 설명해 보세요.
 ===================================================================**/

// 고차함수 - 함수를 파라미터로 사용하거나, 함수실행을 결과를 함수로 리턴하는 함수

// 1) map
// 기존 배열의 각 요소를 새롭게 mapping해서, 즉 각각을 새로운 요소로 만든 후,
// 새로운 배열을 리턴하는 고차함수


// 2) filter
// 기존 배열의 각 요소를 필터링하여서, 어떤 조건에 따라 참(true)이 되는 요소만
// 뽑아내서 새로운 배열을 리턴하는 고차함수


// 3) reduce
// 기존 배열의 각 요소를 결합해서, 마지막 어떤 하나의 결과값으로 리턴하는 고차함수





/**==================================================================
 [10번 문제]
  - 클로저가 뭔가요? 간단한 개념을 설명하고, 클로저에서 강한순환참조(Strong Reference Cycle)
    를 방지할려면 어떻게 해야 하나요?
 ===================================================================**/


// 클로저 - 이름이 없는 함수. 일반적으로 중괄호의 묶음 형태로 표현된 함수
// (코드영역을 가리키는 메모리 주소가 힙 영역에 참조형식으로 저장되어 언제든지 해당 함수를
//  호출가능하도록 메모리 구조가 이루어져 있음)

// 클로저의 캡처리스트 내에서, weak 또는 unowned로 선언을 해줘야 가리키는 인스턴스의
// 레퍼런스 카운팅(RC)를 올라가게 하지 않아,
// 참조형식이 서로가 서로를 가리키는 강한순환참조(Strong Reference Cycle)로 인한
// 메모리 누수(Leak)를 방지 가능






/**==================================================================
 [11번 문제]
  - 스위프트의 메모리 관리 모델인 ARC(Automatic Reference Counting) 시스템은
    무엇을 의미하나요? 아는대로 간단하게 서술하세요.
 ===================================================================**/

// ARC(Automatic Reference Counting)
// 스위프트에서 메모리의 힙(Heap) 영역에 저장되는 클래스의 인스턴스, 클로저(참조타입) 등은
// 적절한 시점에 힙 영역에서 메모리 해제가 되어야 하는데, 이러한 참조타입의 메모리 해제를 위해
// 스위프트에서는 ARC(자동 참조 카운팅)이라는 기법을 사용하고 있음
// ARC 시스템의 핵심은, 해당 참조타입을 가리키는 변수, 속성의 갯수를 세어서,
// 가리키는 숫자가 0이 되었을 때 힙 메모리에서 할당을 해제하는 것임






/**==================================================================
 [12번 문제]
  - HTTP프로토콜이 뭔가요? 아는대로 간단하게 서술하세요.
 ===================================================================**/

// HTTP프로토콜
// HTTP(HyperText Transfer Protocol) - 인터넷 상의 모든 형태의 데이터를 전달하기
// 위한 통신 규약(Protocol). 일반적으로 인터넷 상에서의 데이터를 주고 받기 위한
// 클라이언트 - 서버의 모델로, 애플리케이션 레벨의 프로토콜 TCP/IP위에서 작동함






/**==================================================================
 [13번 문제]
  - 동시성(Concurrency) 프로그래밍이 왜 필요한가요? 간단한 이유를 서술하세요.
 ===================================================================**/

// 동시성 처리를 하지 않으면, 일반적으로 개발자의 모든 코드는 메인(Main) 쓰레드(Thread)
// 즉, 1번 쓰레드에서만 동작하게 되어 있음
// 메인쓰레드는 화면을 1초에 60번 리프레쉬하는 역할도 하고 있기 때문에
// 특히나 네트워킹 처리와 같이, 오래걸리는 작업을 시키면 화면이 버벅거리게 되어 있음
// 따라서, 화면이 버벅 거리지 않게 최적화 처리를 하기 위해서..
// 즉, 2, 3, 4번등의 다른 쓰레드(CPU)도 효율적으로 잘 사용하기 위해서 동시성 프로그래밍이 필요함






/**==================================================================
 [14번 문제]
  - GCD Queue(대기열)가 뭔가요? 아는대로 간단하게 서술하세요.
    (힌트. Thread 쓰레드)
 ===================================================================**/

// iOS에서는 동시성 프로그래밍 처리를 하기위해서, 여러개의 쓰레드를 직접적으로 관리하는
// 것이 아니라.. 쓰레드보다 더 높은 차원에서 대기열(Queue)의 개념을 이용해서
// 쓰레드를 관리함.
// 즉, 애플리케이션에서 쓰레드를 관리하는 것이 아니라, OS(운영체제)에서 대기열의 개념을 사용해서
// 필요한 (소프트웨어적인) 쓰레드 객체를 만들기도 하고, 없애기도 함
// (OS가 알아서 쓰레드 갯수를 관리)






/**==================================================================
 [15번 문제]
  - GCD Queue의 종류는 어떤게 있나요? 아는대로 서술하세요.
 ===================================================================**/

// 메인큐 / 메인쓰레드를 이용하는 직렬큐
// 우리가 짜는 코드는 default로 메인큐(메인쓰레드)에 배치됨
// (일반적으로 다른 쓰레드로 보냈던 작업을 다시 메인쓰레드로 보낼 때 사용)
DispatchQueue.main


// 글로벌큐 - (일반적으로 다른 쓰레드에서) 비동기 처리를 위해, 개발자들 편히 쓰라고
// 자유롭게 사용할 수 있는 대기열(Queue)
// 디폴트로 동시(Concurrent)큐로 설정되어 있고,아래와 같은 우선순위를 가지고 있음
DispatchQueue.global(qos: .userInitiated)
DispatchQueue.global(qos: .userInteractive)
DispatchQueue.global(qos: .default)
DispatchQueue.global(qos: .utility)
DispatchQueue.global(qos: .background)
DispatchQueue.global(qos: .unspecified)


// 커스텀큐
// 개발자가 직접 만들어서 사용할 수 있는 대기열(Queue)
// 디폴트로 직렬(Serial)로 설정되어있지만, 동시큐로 설정하는 것도 가능
DispatchQueue(label: "커스텀")   // 직렬
DispatchQueue(label: "커스텀2", attributes: .concurrent)  // 동시




/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 수고 하셨습니다. 😄
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
