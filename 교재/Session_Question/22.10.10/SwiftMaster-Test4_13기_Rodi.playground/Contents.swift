import UIKit

/*:
 # 앨런 - Swift 마스터 스쿨 13기
 */
/*:
 ## 네번째 테스트 (5주차)
 ---
 */
/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 그동안 배운 내용의 복습 및 약간의 응용이 들어가 있을 뿐입니다. 이 문제를 잘 풀 수 있다고
 좋은 개발자가 될 수 있는 것도 아니고, 실망하거나 좌절할 필요도 없습니다.
 우린 이제 시작일 뿐입니다. 😄
 가장 중요한 것은 포기하지 않고, 꾸준함을 유지하는 것일뿐!
 안풀리면, 다음 문제로 넘어가면되고, 이번에 못풀면 잘 공부해서, 다음 번에 똑같은 문제를 잘 풀면됩니다.
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/

// 서술형의 경우, 주석처리를 하고 작성하면 됩니다.
// (시간이 약간 모자랄 수도 있을 것 같긴한데, 되는 대로 풀어서, 슬랙 DM으로 전달해 주세요!)

// 꼭 정해진 시간 이외에도 풀어보시는대로 전달해 주시면,
// 제가 대략적으로 실력을 파악하는데 도움이 됩니다. (조언도 드릴 수 있고요!)



/**==================================================================
 [1번 문제]
 - 클래스나 구조체에서 initializer(생성자)의 역할이 무엇인가요? 간단하게 서술하세요.
 ===================================================================**/

// 인스턴스 생성시 저장속성의 초기화 입니다.








/**==================================================================
 [2번 문제]
 - 아래 Dog클래스의 생성자를 완성해 보세요.
 ===================================================================**/


// 주석을 제거하고 구현하세요.
class Dog {
  var name: String
  var weight: Int

  // 생성자 구현 하기 (파라미터 이름 구현은 자유)
  init(name: String, weight: Int) {
    self.name = name
    self.weight = weight
  }
}






/**==================================================================
 [3번 문제]
 - 클래스와 구조체의 근본적인 메모리 구조의 차이점에 대해서, 간단하게 설명해주세요.
 (힌트. Heap(힙)과 Stack(스택)을 참고적으로)
 ===================================================================**/

// 클래스의 객체(인스턴스) 생성시 힙에 저장되고 변수는 스택에 저장됩니다.
// 그 변수는 힙에 있는 클래스의 주소를 가리킵니다. (레퍼런스 타입)
// 그렇기 때문에 데이터 복사시 상수로 선언을 해도 내부의 값이 바뀌게 되고(저장되어 있는 메모리 주소가 바뀌는 것이 아니기 때문)
// 복사된 데이터들의 값은 모두 같이 바뀌게 됩니다.
// (클래스 내부의 속성이 상수로 선언 되어있을 경우에는 불가)


// 구조체의 인스턴스는 변수와 같이 스택에 값이 저장됩니다.(값 타입)
// 데이터 복사시에는 각각의 데이터들이 각자의 값을 가지고 있기 때문에 상수로 선언되었을 경우 값을 바꿀 수 없고,
// 변수로 선언되어도 복사된 하나의 인스턴스 값만 바뀌게 됩니다.












/**==================================================================
 [4번 문제]
 - 클래스나 구조체에서 지연(lazy) 저장 속성은 뭔가요? 왜 필요할까요? 간단하게 서술하세요.
 ===================================================================**/

// 인스턴스가 생성될 때 값을 가지고 생성되는 것이 아니라(메모리값을 가지는 것이 아니라)
// 해당 속성에 접근하는 순간에 개별적으로 생성되는 속성입니다.
// 따라서 상수로는 선언이 될 수 없고, 변수로만 선언이 가능합니다.

// 사용하는 이유는 메모리가 많이 필요한 속성을 저장할 때 한번에 메모리에 올릴 필요가 없기 때문에
// 지연저장속성을 활용하여 메모리의 낭비를 막는 것입니다.
// 또한, 다른속성들을 이용해야 할 때 사용합니다.(계산속성의 사용이유와 같습니다.)








/**==================================================================
 [5번 문제]
 - 아래의 코드를 활용해,
 (1) 타입 저장 속성을 구현해보세요. 문자열 타입 저장 속성을 구현하면 됩니다.
 (힌트. 종을 의미하는 species의 변수를 만들어 "Dog"이라는 문자열을
 저장하려고 합니다.)
 (2) 또한 해당 타입 저장 속성에 접근하는 코드를 구현하세요.
 ===================================================================**/



class Dog2 {

  //(여기에) 타입 저장 속성의 구현
  static let species = "Dog"



  var name: String
  var weight: Double

  init(name: String, weight: Double) {
    self.name = name
    self.weight = weight
  }

}


// 그리고 해당 타입 저장 속성에 접근하는 한줄의 코드 구현 (힌트. 타입 속성)

Dog2.species









/**==================================================================
 [6번 문제]
 - 아래의 코드 예제에서, Bclass는 Aclass를 상속하고 있습니다. Bclass의 저장속성인
 z를 고려해서, Bclass의 지정생성자를 한개이상 구현하고, 상위(Aclass)의 지정생성자
 (init(x: Int, y: Int))를 편의생성자로 재정의 해보세요.
 (자유롭게 구현해보세요.)
 ===================================================================**/


class Aclass {
  var x: Int
  var y: Int

  init(x: Int, y: Int) {
    self.x = x
    self.y = y
  }

  convenience init() {
    self.init(x: 0, y: 0)
  }
}



// 아래의 주석을 제거하고 코드를 구현

class Bclass: Aclass {

  var z: Int

  // 이 부분에 지정생성자 및 편의 생성자(상위의 지정생성자를 재정의해서) 구현
  init(x: Int, y: Int, z: Int) {
    self.z = z
    super.init(x: x, y: y)
  }

  convenience override init(x: Int, y: Int) {
    self.init(x: x, y: y, z: 3)
  }


}





/**==================================================================
 [7번 문제]
 - 아래의 코드를 이용해 Singleton패턴 구현을 위한 코드를 완성해 보세요.
 ===================================================================**/



class Singleton {
  // 아래 주석 제거후, 싱글톤 구현을 위한 속성 완성
  let shared = Singleton()
  var userInfoId = 12345

  // 생성자 구현 완성
  private init() {}
}







/**==================================================================
 [8번 문제]
 - 클래스에서 convenience(편의) 생성자는 어떤 개념인가요? 아는대로 간단하게 서술하세요.
 ===================================================================**/


// 지정생성자보다 적은 파라미터로 비교적 편리하게 인스턴스를 생성할 수 있게 해주는 생성자 입니다.
// 지정생성자에 의존하는 방식입니다. (델리게이트 어크로스 - 편의생성자는 해당 클래스의 지정생성자를 호출해야 합니다.)
// 클래스는 상속을 지원하기 때문에 여러 생성자를 지원했을 때 개발자가 실수 할 수 있는 가능성이 있습니다.
// 편의생성자를 사용하면 개발자의 실수 가능성을 어느정도 배제할 수 있습니다.










/**==================================================================
 [9번 문제]
 - 아래의 SubClass에서, 상위의 SuperClass의 sayHello 메서드를 재정의해서,
 아래 처럼 출력되도록 구현해 보세요.
 
 "안녕하세요."   // super호출 코드로 구현
 "반갑습니다."
 "잘 부탁드려요."
 ===================================================================**/


class SuperClass {
  func sayHello() {
    print("안녕하세요.")
  }
}



class SubClass: SuperClass {
  // 메서드 재정의 코드 구현
  override func sayHello() {
    super.sayHello()
    print("반갑습니다.")
    print("잘 부탁드려요.")
  }


}


// 코드 실행
var subClass = SubClass()
subClass.sayHello()


// 원하는 출력
// "안녕하세요."
// "반갑습니다."
// "잘 부탁드려요."





/**==================================================================
 [10번 문제]
 - 아래의 코드는 앱을 만들 때 쓰이는 뷰컨트롤러 코드입니다. 내부에서, 버튼이 눌리면
 버튼의 제목이 바뀌는 코드를 구현하려고합니다. (그리고 아래의 코드는 스토리 보드와
 연결되어 있다고 가정합니다. 실제는 아니더라도)
 - 현재는 버튼의 제목이 "누르세요"라고 되어있다고 가정하고, 버튼을 실제 누르면
 버튼의 제목이 "눌렀음"으로 변경되도록 구현하려는 상황을 가정하는 예시입니다.
 - 아래, 버튼의 제목이 바뀌는 코드를 구현하세요.
 (참고. 타입 캐스팅의 예시 상황 이해를 위한 코드)
 (힌트. button의 타이틀(제목)을 바꿀 수 있는 메서드가 뭐였죠?)
 ===================================================================**/


class ViewController {

  @IBAction func buttonDidTapped(sender: Any) {
    let button = sender as! UIButton

    // 버튼의 타이틀(제목)을 바꾸는 코드를 작성 ==> 버튼은 "눌렸음"라는 타이틀로 변경하려함
    //    button.setTitle("눌렸음", for: .normal)
  }

}





/**==================================================================
 [11번 문제]
 - 아래의 코드는 부모클래스를 상속하는, 상속관계의 코드입니다. 현재 Undergraduate
 인스턴스가 Person타입으로 person1 상수에 담겨있는데,
 해당 인스턴스가 가진 저장 속성 중에 하나인 "전공"을 출력하려고 합니다.
 print(person1.major)
 전공을 출력하기 위해, 필요한 코드를 중간에 삽입하세요.
 (힌트. 타입 캐스팅)
 ===================================================================**/


class Person {
  var id = 0
}

class Student: Person {
  var studentId = 1
}

class Undergraduate: Student {
  var major = "전공"
}



let person1: Person = Undergraduate()

// 아래 "전공"을 출력하기 위해서, 중간에 코드를 삽입하세요.
// (필요한 경우, 프린트 코드의 person1 상수를 변경해도 됩니다.)
if let major = person1 as? Undergraduate {
  print(major.major)
}






//print(person1.major)    // "전공" 출력을 원함
// 옵셔널 바인딩으로 했습니다.



/**==================================================================
 [12번 문제]
 - 클래스와 구조체, 열거형에서 확장(Extension)의 개념이 뭘까요? 간단하게 서술하세요.
 ===================================================================**/


// 상속은 클래스에서만 가능하고 상위와 하위가 나뉘는 수직으로의 확장이라면, 확장은 수평적인 확장을 말하는 것입니다.
// 이미 존재하는 타입에 메서드를 추가하는 것입니다.
// 저장속성은 확장이 불가합니다.(추가적인 메모리 공간이 필요하기 때문입니다.)









/**==================================================================
 [13번 문제]
 - 프로토콜(Protocol)의 개념이 뭘까요? 간단하게 서술하세요.
 ===================================================================**/


// 클래스에서만 1.상속이 되고 2.다중상속은 불가하며 3.상위클래스의 메모리구조를 따라가야합니다.
// 그 단점을 보완하기 위해 나온 개념입니다.(구조체, 열거형 가능)

// 속성, 메서드 둘 다 정의 할 수 있으며
// 요구사항의 최소한만 적으면 됩니다.









/**==================================================================
 [14번 문제]
 - 아래의 RemoteControl 프로토콜을 채택한 SmartPhone 클래스의 구현을 완성하세요.
 (조건)
 (1) name 속성은 계산 속성으로 구현하세요.
 get블록 - "아이폰"을 리턴하도록 구현
 set블록 - 내부 구현은 안해도 됨
 (2) turnOff 메서드는
 "꺼졌습니다."를 출력하도록 구현
 ===================================================================**/

// RemoteControl 프로토콜
protocol RemoteControl {
  var name: String { get }
  func turnOff()
}


// RemoteControl 프로토콜을 채택한 SmarPhone클래스
class SmartPhone: RemoteControl {
  var name: String {
    return "아이폰"
  }

  // 내부 구현
  func turnOff() {
    print("꺼졌습니다.")
  }

}






/**==================================================================
 [15번 문제]
 - 아래에서는 함수를 정의(1)하고, 해당 함수를 실행(2)하는 코드입니다. 아래의 (2)코드를
 간단한 형태 클로저로 변형하세요. 아는 한에서 가장 간단한 형태로 변형한 클로저를
 작성하시면 됩니다.
 ===================================================================**/


// (1) (콜백함수를 사용한)함수를 정의

func performClosure(param: (String) -> Int) {
  param("Swift")
}

// (2) 변형하고자 하는 클로저의 형태 (변형 전) - 위에서 정의된 함수를 실행 / 실행하면서, 클로저(함수)를 사용

performClosure(param: { (str: String) in
  return str.count
})


// (변형하고자 하는 코드) 가장 간단한 형태의 클로저로 변형된 코드를 작성

performClosure { str in
  str.count
}










/**>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
 수고 하셨습니다. 😄
 >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>**/
